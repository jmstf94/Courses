\chapter{Μέθοδος {\en Jacobi}}
Η πιο απλή επαναληπτική μέθοδος για την αριθμητική επίλυση γραμμικού συστήματος είναι η μέθοδος του {\en Jacobi}. Όπως και στην περίπτωση της απαλοιφής {\en Gauss} υποθέτουμε ότι το σύστημα έχει μοναδική λύση και ότι δεν υπάρχουν μηδενικά στη διαγώνιο του πίνακα $A$.

Η επαναληπτική μέθοδο αποτελείται από τον επαναλαμβανόμενο υπολογισμό του σετ $\{x_n \}$ με τις εξισώσεις:
\begin{equation}
\begin{aligned}
x_1 &=\frac{1}{a_{11}}\left(b_1-a_{12} x_2-a_{13} x_3-\cdots-a_{1 n} x_n\right) \\
x_2 &=\frac{1}{a_{22}}\left(b_2-a_{21} x_1-a_{23} x_3-\cdots-a_{2 n} x_n\right) \\
& \vdots \\
x_n &=\frac{1}{a_{n n}}\left(b_n-a_{n 1} x_1-a_{n 2} x_2-\cdots-a_{n, n-1} x_{n-1}\right)
\end{aligned}
\end{equation}
Συνήθως επιλέγουμε ως αρχικές τιμές των μεταβλητών μας το $0$. Το διάνυσμα $\mathbf{x}$ θα προσεγγίζει την πραγματική λύση μετά από κάποιον αριθμό επαναλήψεων. Πάμε να εκτελέσουμε χειροκίνητα τη μέθοδο για μερικές επαναλήψεις. Πρώτα για ένα σύστημα που αποκλίνει και στη συνέχει για ένα που συγκλίνει. 
\en
\begin{python}
import numpy as np
#######divergent example#########
######define the system######
A = np.array([[1,2,-3],[3,-1,4],[-2,1,1]])
b = np.array([7,6,1])

######we start fromm the zeroth vector######
x_1 = np.array([b[0]/A[0,0],b[1]/A[1,1],b[2]/A[2,2]])
print(f"First iteration: {x_1}")

x_2 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_1[1]-A[0,2]*x_1[2]),(1/A[1,1])*(b[1]-A[1,0]*x_1[0]-A[1,2]*x_1[2]),(1/A[2,2])*(b[2]-A[2,0]*x_1[0]-A[2,1]*x_1[1])])
print(f"Second iteration: {x_2}")

x_3 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_2[1]-A[0,2]*x_2[2]),(1/A[1,1])*(b[1]-A[1,0]*x_2[0]-A[1,2]*x_2[2]),(1/A[2,2])*(b[2]-A[2,0]*x_2[0]-A[2,1]*x_2[1])])
print(f"Second iteration: {x_3}")

x_4 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_3[1]-A[0,2]*x_3[2]),(1/A[1,1])*(b[1]-A[1,0]*x_3[0]-A[1,2]*x_3[2]),(1/A[2,2])*(b[2]-A[2,0]*x_3[0]-A[2,1]*x_3[1])])
print(f"Fourth iteration: {x_4}")

x_5 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_4[1]-A[0,2]*x_4[2]),(1/A[1,1])*(b[1]-A[1,0]*x_4[0]-A[1,2]*x_4[2]),(1/A[2,2])*(b[2]-A[2,0]*x_4[0]-A[2,1]*x_4[1])])
print(f"Fifth iteration: {x_5}")

x_6 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_5[1]-A[0,2]*x_5[2]),(1/A[1,1])*(b[1]-A[1,0]*x_5[0]-A[1,2]*x_5[2]),(1/A[2,2])*(b[2]-A[2,0]*x_5[0]-A[2,1]*x_5[1])])
print(f"Sixth iteration: {x_6}")

x_7 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_6[1]-A[0,2]*x_6[2]),(1/A[1,1])*(b[1]-A[1,0]*x_6[0]-A[1,2]*x_6[2]),(1/A[2,2])*(b[2]-A[2,0]*x_6[0]-A[2,1]*x_6[1])])
print(f"Sixth iteration: {x_7}")
\end{python}
\vspace*{-0.7cm}
\begin{codeout}
First iteration: [ 7. -6.  1.]
Second iteration: [22. 19. 21.]
Second iteration: [ 32. 144.  26.]
Fourth iteration: [-203.  194.  -79.]
Fifth iteration: [-618. -931. -599.]
Sixth iteration: [   72. -4256.  -304.]
Sixth iteration: [ 7607. -1006.  4401.]
\end{codeout}
\begin{python}
#######convergent example#########
######define the system######
A = np.array([[5,-2,3],[-3,9,1],[2,-1,-7]])
b = np.array([-1,2,3])

######we start fromm the zeroth vector######
x_1 = np.array([b[0]/A[0,0],b[1]/A[1,1],b[2]/A[2,2]])
print(f"First iteration: {x_1}")

x_2 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_1[1]-A[0,2]*x_1[2]),(1/A[1,1])*(b[1]-A[1,0]*x_1[0]-A[1,2]*x_1[2]),(1/A[2,2])*(b[2]-A[2,0]*x_1[0]-A[2,1]*x_1[1])])
print(f"Second iteration: {x_2}")

x_3 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_2[1]-A[0,2]*x_2[2]),(1/A[1,1])*(b[1]-A[1,0]*x_2[0]-A[1,2]*x_2[2]),(1/A[2,2])*(b[2]-A[2,0]*x_2[0]-A[2,1]*x_2[1])])
print(f"Second iteration: {x_3}")

x_4 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_3[1]-A[0,2]*x_3[2]),(1/A[1,1])*(b[1]-A[1,0]*x_3[0]-A[1,2]*x_3[2]),(1/A[2,2])*(b[2]-A[2,0]*x_3[0]-A[2,1]*x_3[1])])
print(f"Fourth iteration: {x_4}")

x_5 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_4[1]-A[0,2]*x_4[2]),(1/A[1,1])*(b[1]-A[1,0]*x_4[0]-A[1,2]*x_4[2]),(1/A[2,2])*(b[2]-A[2,0]*x_4[0]-A[2,1]*x_4[1])])
print(f"Fifth iteration: {x_5}")

x_6 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_5[1]-A[0,2]*x_5[2]),(1/A[1,1])*(b[1]-A[1,0]*x_5[0]-A[1,2]*x_5[2]),(1/A[2,2])*(b[2]-A[2,0]*x_5[0]-A[2,1]*x_5[1])])
print(f"Sixth iteration: {x_6}")

x_7 = np.array([(1/A[0,0])*(b[0]-A[0,1]*x_6[1]-A[0,2]*x_6[2]),(1/A[1,1])*(b[1]-A[1,0]*x_6[0]-A[1,2]*x_6[2]),(1/A[2,2])*(b[2]-A[2,0]*x_6[0]-A[2,1]*x_6[1])])
print(f"Sixth iteration: {x_7}")
\end{python}
\vspace*{-0.7cm}
\begin{codeout}
First iteration: [-0.2         0.22222222 -0.42857143]
Second iteration: [ 0.14603175  0.2031746  -0.51746032]
Second iteration: [ 0.19174603  0.32839506 -0.41587302]
Fourth iteration: [ 0.18088183  0.33234568 -0.42070043]
Fifth iteration: [ 0.18535853  0.32926066 -0.42436886]
Sixth iteration: [ 0.18632558  0.33116049 -0.42264909]
Sixth iteration: [ 0.18605365  0.33129176 -0.42264419]
\end{codeout}
\gr

Αξίζει να σημειωθεί ότι η συνθήκη σύγκλισης είναι:
\begin{equation}
\rho\left(D^{-1}(L+U)\right)<1
\end{equation}
όπου $\rho(A)=\max \left\{\left|\lambda_1\right|, \ldots,\left|\lambda_n\right|\right\}$, $D$ ο διαγώνιος πίνακας, $L,U$ οι πίνακες από την παραγοντοποίηση $LU$. 
