\chapter{Αριθμητική Επίλυση Γραμμικού Συστήματος}
Το πιο σημαντικό πρόβλημα που καλούμαστε να λύσουμε μέσω της γραμμικής άλγεβρας είναι η επίλυση γραμμικών συστημάτων. Σχεδόν, οποιαδήποτε μεθοδολογία διδάσκετε έχει έμμεση ή άμεση σχέση με την επίλυση γραμμικού συστήματος. Γενικά, ένα γραμμικό σύστημα είναι μία εξίσωση της μορφής:
\begin{equation}
A \mathbf{x}=\mathbf{b}
\label{system_equation}
\end{equation}
όπου $A$ είναι ένας $m \times n$ πίνακας, $\mathbf{x}$ είναι ένα στηλοδιάνυσμα με $n$ βαθμωτές μεταβλητές , και το $\mathbf{b}$ είναι πάλι στηλοδιάνυσμα αλλά με $m$ στοιχεία.
\begin{equation}
A=\left[\begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1 n} \\
a_{21} & a_{22} & \cdots & a_{2 n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m 1} & a_{m 2} & \cdots & a_{m n}
\end{array}\right], \quad \mathbf{x}=\left[\begin{array}{c}
x_1 \\
x_2 \\
\vdots \\
x_n
\end{array}\right], \quad \mathbf{b}=\left[\begin{array}{c}
b_1 \\
b_2 \\
\vdots \\
b_m
\end{array}\right]
\end{equation}
Ουσιαστικά, έχουμε το σύνολο των εξισώσεων:
\begin{equation}
\left\{\begin{array}{l}
a_{11} x_1+a_{12} x_2+\cdots+a_{1 n} x_n=b_1 \\
a_{21} x_1+a_{22} x_2+\cdots+a_{2 n} x_n=b_2 \\
\vdots \\
a_{m 1} x_1+a_{m 2} x_2+\cdots+a_{m n} x_n=b_m
\end{array}\right.
\end{equation}
με αγνώστους τα $x_1,x_2 \cdots x_n$, όπου για να έχουμε ένα καλώς ορισμένο πρόβλημα θα πρέπει τα αθροίσματα των γραμμών του πίνακα $A$ να μην είναι 0.

Προκειμένου λοιπόν να επιλύσουμε το σύστημα αριθμητικά θα πρέπει να εκμεταλλευτούμε την γνώση μας για τα στοιχεία του πίνακα $A$ και του $b$. Οι αλγοριθμικοί τρόποι επίλυσης που χρησιμοποιούν αυτά τα δύο αριθμητικά αντικείμενα είναι εύκολα προγραμματίσιμη με την χρήση της {\en numpy}. Υπάρχουν δύο βασικές κατηγορίες αριθμητικών μεθόδων για την επίλυση γραμμικών συστημάτων, οι ακριβείς και οι επαναληπτικές. Πριν ξεκινήσουμε να δίνουμε παραδείγματα μεθόδων δείχνουμε με ένα μικρό {\en script} πόσο εύκολα μπορεί η {\en numpy} να λύσει ένα γραμμικό σύστημα:
\en
\begin{python}
from numpy.linalg import solve
import numpy as np
######define the system#######
A = np.array([[2,1],[3,1]])
b = np.array([1,1])
####print the variable vector#####
print(solve(A,b))
\end{python}
\vspace*{-0.7cm}
\begin{codeout}
[0. 1.]
\end{codeout}
\gr
\section{Αντίστροφος πίνακας και ορίζουσα}
Όταν μιλάμε για επίλυση συστήματος γραμμικών εξισώσεων ουσιαστικά το πρόβλημα που προσπαθούμε να λύσουμε είναι η εύρεση του αντίστροφου του πίνακα $Α$. Πολλές φορές μάλιστα βλέπουμε στη βιβλιογραφία, τις μεθόδους επίλυσης συστήματος (πχ απαλοιφή {\en Gauss}) να αναφέρονται ως μέθοδοι υπολογισμού αντίστροφου πίνακα.
Ο αντίστροφος πίνακας $Β$ ενός αντιστρέψιμου $n \times n$ πίνακα $A$ είναι ο πίνακας για τον οποίο ισχύει:
\begin{equation}
AB=BA=I_n
\end{equation}
και συμβολίζεται με $A^{-1}$. Το σύμβολο $I_n$ αναπαριστά τον μοναδιαίο πίνακα με την ιδιότητα $I_nA=A$ και την μορφή:
\begin{equation}
I_n=\left[\begin{array}{ccccc}
1 & 0 & 0 & \cdots & 0 \\
0 & 1 & 0 & \cdots & 0 \\
0 & 0 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & \cdots & 1
\end{array}\right]
\end{equation}

Ένας πίνακας $Α$ είναι αντιστρέψιμος αν και μόνο αν η ορίζουσα $detA$ του πίνακα είναι διαφορετική του μηδενός. Η ορίζουσα είναι ουσιαστικά μία συνάρτηση από των χώρο του πίνακα $\mathbb{R}^{n \times n}$ στον άξονα των πραγματικών αριθμών $\mathbb{R}$. Ο τύπος υπολογισμού για αυθαίρετη διάσταση $n$ είναι το ανάπτυγμα {\en Laplace} στο οποίο προστίθενται/αφαιρούνται όλες οι ορίζουσες των υποπινάκων του $A$ πολλαπλασιασμένες με το κατάλληλο στοιχείο του πίνακα. Αντί να σχολιάσουμε σε βάθος τον αναλυτικό τύπο θα εξηγήσουμε την περίπτωση των δύο και των τριών διαστάσεων. Η λογική είναι προφανώς μεταβιβάσιμη και γενικεύεται για οποιονδήποτε αριθμό διαστάσεων. 

Στις δύο διαστάσεις η ορίζουσα ορίζεται ως:
\begin{equation}
|A|=\left|\begin{array}{ll}
a & b \\
c & d
\end{array}\right|=a d-b c
\end{equation}
ενώ στις 3 διαστάσεις:
\begin{equation}
\begin{aligned}
det(A)=|A|=\left|\begin{array}{lll}
a & b & c \\
d & e & f \\
g & h & i
\end{array}\right| &=a\left|\begin{array}{cc}
e & f \\
h & i
\end{array}\right|-b\left|\begin{array}{ll}
d & f \\
g & i
\end{array}\right|+c\left|\begin{array}{ll}
d & e \\
g & h
\end{array}\right| \\
&=a e i+b f g+c d h-c e g-b d i-a f h
\end{aligned}
\end{equation}
Η απλοποιημένη λογική πίσω από τον υπολογισμό της ορίζουσας τριών διαστάσεων(και κατ' επέκταση όλων των διαστάσεων) έχει ως εξής:
\begin{itemize}
\item Επιλέγουμε την πρώτη γραμμή του πίνακα.
\item Στη συνέχεια διαδοχικά επιλέγουμε τις στήλες του πίνακα μία-μία από αριστερά προς τα δεξιά
\item Για κάθε διαδοχική επιλογή στήλης, στο αποτέλεσμα της ορίζουσας προσθέτουμε ή αφαιρούμε εναλλάξ, το γινόμενο του αντίστοιχου αριθμού της πρώτης γραμμής με την ορίζουσα του υποπίνακα που δεν είναι επιλεγμένος.
\item Επαναλαμβάνουμε την διαδικασία μέχρι να καταλήξουμε σε πραγματικό αριθμό.
\end{itemize}
Φυσικά στην περίπτωση της {\en numpy} μπορούμε εύκολα να υπολογίσουμε την ορίζουσα ενός πίνακα ως:
\en
\begin{python}
from numpy.linalg import det
A = np.array([[2,1],[3,1]])
print(det(A))
\end{python}
\vspace*{-0.7cm}
\begin{codeout}
-1.0000000000000002
\end{codeout}
\gr
Στην περίπτωση που ο πίνακας που εισάγουμε στην εντολή {\en det} δεν είναι τετραγωνικός, θα δούμε στο {\en output} την ένδειξή {\en LinAlgError}.

Ο τρόπος με τον οποίο συνδέεται το πρόβλημα υπολογισμού του αντίστροφου με την επίλυση γραμμικού συστήματος έρχεται αν πολλαπλασιάσει κανείς την εξίσωση \eqref{system_equation} από αριστερά με τον πίνακα $Α^{-1}$:
\begin{equation}
\mathbf{x}= A^{-1} \mathbf{b}
\label{system_equation}
\end{equation}
Έτσι κάθε επίλυση συστήματος με ίδιο αριθμό μεταβλητών και εξισώσεων (δηλαδή τετραγωνικό πίνακα Α) μπορεί να αναχθεί σε πρόβλημα υπολογισμού αντιστρόφου. Ας λύσουμε με αυτόν τον τρόπο το προηγούμενο σύστημα εξισώσεων χρησιμοποιώντας {\en numpy}: 
\en
\begin{python}
from numpy.linalg import inv
from numpy import matmul
######define the system#######
A = [[2,1],[3,1]]
b = [1,1]
####calculate solution vector x#####
x = matmul(inv(A),b)
print(x)
\end{python}
\vspace*{-0.7cm}
\begin{codeout}
[1.11022302e-16 1.00000000e+00]
\end{codeout}
\gr
Παρατηρούμε μία ιδιαιτερότητα της {\en numpy}. Επειδή κάποιες εντολές και υπολογισμοί, περιέχουν αριθμητικές επαναληπτικές μεθόδους, σε συνδυασμό με την δυνατότητα της βιβλιοθήκης να διατηρεί πολύ μεγάλη ακρίβεια στους υπολογισμούς της, υπάρχει περίπτωση μια λύση να τείνει προσεγγιστικά στην πραγματική τιμή. Αν παρατηρήσουμε το πρώτο στοιχείο του διανύσματος $x$, βλέπουμε ότι είναι ένας αριθμός της τάξης του $10^{-16}$ δηλαδή πολύ κοντά στο $0$. Αυτό συμβαίνει λόγω του αλγόριθμου υπολογισμού. Αν θέλουμε να στρογγυλοποιήσουμε για περισσότερη ευκρίνεια:
\en
\begin{python}
####round to fifth decimal#####
print(x.round(5))
\end{python}
\vspace*{-0.7cm}
\begin{codeout}
[0. 1.]
\end{codeout}
\gr
Παρατηρούμε ότι στην περίπτωση που ο πίνακας δεν είναι αντιστρέψιμος δηλαδή το σύστημά μας είναι είτε αόριστο είτε αδύνατο, η python θα τυπώσει {\en LinAlgError: Singular matrix}.
